# 7 Creating RDF Terms with Term Maps

An _**RDF term**_ is either an [IRI](), or a [blank node](), or a [literal]().

A [term map]() is a function that generates an [RDF term]() from a logical iteration.
The result of that function is known as the [term map]()'s generated [RDF term]().

Term maps are used to generate the subjects, predicates and objects of the [RDF triples]()
that are generated by a [triples map]().
Consequently, there are several kinds of [term maps](),
depending on where in the mapping they occur:
[subject maps](), [predicate maps](), [object maps]() and [graph maps]().

A [term map]() MUST be exactly one of the following:

* a [constant-valued term map](),
* a [column-valued term map](),
* a [template-valued term map]().

The _**references**_ of a [term map]()
are the set of +++???+++ referenced in the [term map]()
and depend on the type of [term map]().

## 7.1 Constant (rml:constant)

A _**constant-valued term map**_ ignores the logical iteration
and always generates the same [RDF term]().
A [constant-valued ter map]() is represented by a resource
that has exactly one `rml:constant` property.

The [constant valued term map]() is the [RDF term]()
that is the value of its `rml:constant` property.

If the [constant-valued term map]() is a [subject map](), [predicate map]() or [graph map](),
then its constant value MUST be an IRI.

If the [constant-valued term map]() is an [object map](),
then its constant value MUST be an [IRI]() or [literal]().

The [reference] of a [constant-valued]() is the empty set.

[Constant-valued term maps]() can be expressed more concisely
using the _**constant shortcut properties**_
`rml:subject`, `rml:predicate`, `rml:object` and `rml:graph`.
Occurrences of these properties MUST be treated exactly as if
the following triples were present in the mapping graph instead:

| Triple involving constant shortcut property | Replacement triples  |
| :-------------| :-----|
| ?x rml:subject ?y. | ?x rml:subjectMap [ rml:constant ?y ]. | 
| ?x rml:predicate ?y. | ?x rml:predicateMap [ rml:constant ?y ]. |
| ?x rml:object ?y. | ?x rml:objectMap [ rml:constant ?y ]. |
| ?x rml:graph ?y. |  	?x rml:graphMap [ rml:constant ?y ]. |


+++ ADD example +++

## 7.2 From a Reference (rml:reference)

A _**reference-valued term map**_ is represented by a resource
that has exactly one `rml:reference` property.

The value of the `rml:reference` property MUST be a valid reference.
The _**column value**_ of the [term map]() is the data value of that reference
in a given logical iteratino.

The [reference]() is the singleton set containing the value of the `rml:reference` property.

+++ ADD example +++

## 7.3 From a Template (rml:template)

A [template-valued term map]() is represented by a resource
that has exactly one `rml:template` property.
The value of the `rml:template` property MUST be a valid [string template]().

A _**string template**_ is a format string that can be used
to build strings from multiple components.
It can reference [references]() by enclosing them in curly braces (“{” and “}”).
The following syntax rules apply to valid string templates:

* Pairs of unescaped curly braces MUST enclose valid references.
* Curly braces that do not enclose references MUST be escaped by a backslash character (“\”).
This also applies to curly braces within references.
* Backslash characters (“\”) MUST be escaped by preceding them with another backslash character, yielding “\\”. This also applies to backslashes within column names.
* There SHOULD be at least one pair of unescaped curly braces.
* If a template contains multiple pairs of unescaped curly braces,
then any pair SHOULD be separated from the next one by a _**safe separator**_.
This is any character or string
that does not occur anywhere in any of the data values of either reference;
or in the [IRI-safe versions]() of the data values,
if the [term type]() is `rml:IRI`.

The _**template value**_ of the [term map]() for a given logical iteration
is determined as follows:

1. Let result be the [template string]()
2. For each pair of unescaped curly braces in result:
    1. Let value be the data value of the column whose name is enclosed in the curly braces
    2. If value is NULL, then return NULL
    3. Let value be the [natural RDF lexical form]() corresponding to value
        If the [term type]() is `rml:IRI`,
        then replace the pair of curly braces with an [IRI-safe version]() of value;
        otherwise, replace the pair of curly braces with value
3. Return result

The IRI-safe version of a string is obtained by applying the following transformation
to any character that is not in the iunreserved production in [[RFC3987]]():

1. Convert the character to a sequence of one or more octets using UTF-8 [[RFC3629]]()
2. Percent-encode each octet [[RFC3986]]()

The following table shows examples of strings and their IRI-safe versions:


| String | IRI-safe version  |
| :-------------| :-----|
| 42 | 42 | 
| Hello World! | Hello%20World%21 |
| 2011-08-23T22:17:00Z | 2011-08-23T22%3A17%3A00Z |
| ~A_17.1-2 |  ~A_17.1-2 |

**NOTE**
RML always performs percent-encoding when IRIs are generated from string templates.
If IRIs need to be generated without percent-encoding,
then `rml:reference` should be used instead of `rml:template`,
with a logical data source that performs the string concatenation.

In the case of string templates that generate IRIs,
any single character that is legal in an IRI,
but percent-encoded in the [IRI-safe version]() of a data value, is a safe separator.
This includes in particular the eleven sub-delim characters defined in [[RFC3987]]():
!$&'()*+,;=

The [reference]() of a [template-valued term map]()
is the set of column names enclosed in unescaped curly braces in the [template string]().

The following example defines a [subject map]()
that generates [IRIs]() from ??? of a logical data source.

+++ ADD EXAMPLE +++

Using the sample iteration from ??? as a logical data source,
the template value of the [subject map]() would be:

+++ ADD EXAMPLE +++

The following example shows how an [IRI-safe]() template value is created:

+++ ADD EXAMPLE +++

Using the sample iteration from ??? as a logical data source,
the template value of the [subject map]() would be:

+++ ADD EXAMPLE +++

The space character is not in the iunreserved set,
and therefore percent-encoding is applied to the character, yielding “%20”.

The following example shows the use of backslash escapes in string templates.
The template will generate a fancy title such as

{{{ \o/ Hello World! \o/ }}}

from a string “Hello World!” in the referernce.
By default, `rml:template` generates IRIs.
Since the intention here is to create a literal instead,
the [term type]() has to be set.

+++ ADD EXAMPLE +++


Note that because
[backslashes need to be escaped by a second backslash in the Turtle syntax]() [[TURTLE]],
a double backslash is needed to escape each curly brace,
and to get one literal backslash in the output
one needs to write four backslashes in the template.

## 7.4 IRIs, Literal, Blank Nodes (rml:termType)

The term type of a [column-valued term map] or [template-valued term map]
determines the kind of [generated RDF term]() ([IRIs](), [blank nodes]() or [literals]()).

If the term map has an optional `rml:termType` property,
then its [term type]() is the value of that property.
The value MUST be an [IRI]() and MUST be one of the following options:

* If the term map is a [subject map](): `rml:IRI` or `rml:BlankNode`
* If the term map is a [predicate map](): `rml:IRI`
* If the term map is an [object map](): `rml:IRI`, `rml:BlankNode`, or `rml:Literal`
* If the term map is a [graph map](): `rml:IRI`


If the [term map]() does not have a `rml:termType` property, then its term type is:

* `rml:Literal`, if it is an [object map]()
and at least one of the following conditions is true:
* It is a [column-based term map]().
    * It has a `rml:language` property (and thus a [specified language tag]()).
    * It has a `rml:datatype` property (and thus a [specified datatype]()).
* rml:IRI, otherwise.

**NOTE**

Term maps with term type `rml:IRI` cause [data errors]()
if the value is not a valid IRI (see [generated RDF term]() for details).
Data values from the input database may require percent-encoding
before they can be used in IRIs.
[Template-valued term maps]() are a convenient way of percent-encoding data values.


**NOTE**

[Constant-valued term maps]() are not considered as having a term type,
and specifying `rml:termType` on these [term maps]() has no effect.
The type of the generated [RDF term]() is determined directly by the value of `rml:constant`:
If it is an [IRI](), then an [IRI]() will be generated;
if it is a literal, a literal will be generated.

## 7.5 Language Tags (rml:language)

A [term map]() with a term type of `rml:Literal` MAY have a specified language tag.
It is represented by the `rml:language` property on a [term map]().
If present, its value MUST be a valid language tag.

A specified language tag causes generated literals to be language-tagged plain literals.
In the following example,
plain literals with language tag “en-us” (U.S. English)
will be generated for the data values in the DNAME column.

+++ ADD EXAMPLE +++


## 7.6 Typed Literals (rml:datatype)

A _**datatypeable term map**_ is a term map with a term type of `rml:Literal`
that does not have a [specified language tag]().

Datatypeable term maps may generate [typed literals]().
The datatype of these literals can be automatically determined
based on the SQL datatype of the underlying logical table column
(producing a [natural RDF literal]()),
or it can be explicitly overridden using `rml:datatype`
(producing a [datatype-override RDF literal]()).

A [datatypeable term map]() MAY have a `rml:datatype` property.
Its value MUST be an [IRI](). This [IRI]() is the specified datatype of the [term map]().

A [term map]() MUST NOT have more than one `rml:datatype` value.

A [term map]() that is not a datatypeable term map MUST NOT have an `rml:datatype` property.

See generated [RDF term]() for further details on generating literals from [term maps]().

**NOTE**

One cannot explicitly state that a [plain literal]()
without language tag should be generated.
To generate one from a non-string reference,
a [template-valued term map]() with a template such as "{MY_REFERENCE}"
and a term type of `rml:Literal` can be used.

The following example shows an [object map]()
that explicitly specifies `xsd:positiveInteger` type.
A [datatype-override RDF literal] of that datatype will be generated.

+++ ADD EXAMPLE +++





























